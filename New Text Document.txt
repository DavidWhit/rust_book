// use actix_http::ResponseBuilder;
use actix_web::{
    // error,
    // http::header,
    http::StatusCode,
    web, HttpResponse, Responder, Result};
use failure::Fail;
// use log::error;
use odbc::*;
use r2d2;
use r2d2_odbc::ODBCConnectionManager;
use rustforce::response::{
    // ErrorResponse,
    QueryResponse};
use rustforce::{Client };
use serde::{Deserialize, Serialize};
use std::env;
use std::fmt;

#[derive(Deserialize, Debug, Serialize)]
#[serde(rename_all = "PascalCase")]
struct Cases {
    #[serde(rename(serialize = "case_number", deserialize = "CaseNumber"))]
    case_number: String,
    #[serde(rename(serialize = "case_desc", deserialize = "Subject"))]
    case_desc: String,
    #[serde(rename(serialize = "case_contact_name", deserialize = "Contact_Name__c"))]
    case_contact_name: Option<String>,
    #[serde(rename(serialize = "case_owner", deserialize = "Owner"))]
    case_owner: Owner,
    #[serde(rename(serialize = "case_last_updated", deserialize = "LastModifiedDate"))]
    case_last_updated: String,
    #[serde(rename(serialize = "case_created_date", deserialize = "CreatedDate"))]
    case_created_date: String,
    #[serde(rename(serialize = "case_status", deserialize = "Status"))]
    case_status: String,
    #[serde(rename(serialize = "case_resolution", deserialize = "Resolution__c"))]
    case_resolution: Option<String>,
    #[serde(rename(serialize = "case_issue", deserialize = "As_Stated_By_Customer__c"))]
    case_issue: Option<String>,
    #[serde(rename(serialize = "work_order", deserialize = "WorkOrders"))]
    work_orders: Option<WorkOrders>,
}

#[derive(Deserialize, Debug, Serialize)]
struct WorkOrders {
    records: Vec<WorkOrder>,
}

#[derive(Deserialize, Debug, Serialize)]
#[serde(rename_all = "PascalCase")]
struct WorkOrder {
    #[serde(rename(serialize = "work_order_asset", deserialize = "Asset_Number__c"))]
    work_order_asset: Option<String>,
    #[serde(rename(serialize = "work_order_issue", deserialize = "Issue_as_Stated_by_Customer__c"))]
    work_order_issue: Option<String>,
    #[serde(rename(serialize = "work_order_resolution", deserialize = "Resolution__c"))]
    work_order_resolution: Option<String>,
    #[serde(rename(serialize = "work_order_status", deserialize = "Status"))]
    work_order_status: String,
    #[serde(rename(serialize = "work_order_number", deserialize = "WorkOrderNumber"))]
    work_order_number: String,
    #[serde(rename(serialize = "work_order_owner", deserialize = "Owner"))]
    work_order_owner: Owner,
}

#[derive(Deserialize, Debug, Serialize)]
#[serde(rename_all = "PascalCase")]
struct Owner {
    name: String,
}

#[derive(Debug)]
struct DBError {
    details: String
}

impl DBError {
    fn new(msg: &str) -> DBError {
        DBError{details: msg.to_string()}
    }
}

impl fmt::Display for DBError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}",self.details)
    }
}

impl std::error::Error for DBError {
    fn description(&self) -> &str {
        & self.details
    }
}

struct AppState {
    pool: r2d2::Pool<ODBCConnectionManager>,
    client: rustforce::Client,
}

fn get_sf_account(
    site: &u32,
    pool: &r2d2::Pool<ODBCConnectionManager>,
) -> Result<String, Box<dyn std::error::Error>> {
    let pool_connection = pool.get()?;
    let con = pool_connection.raw();

    let stmt = Statement::with_parent(&con)?;
    let sql_string = "SELECT SfAccountId
                             FROM sites
                            WHERE LicensedForRhythm = 1
                              AND IDSite = ?";

    let stmt = stmt.prepare(sql_string);
    let stmt = stmt?.bind_parameter(1, site)?;

    let mut results: Vec<String> = vec![];

    if let Data(mut stmt) = stmt.execute()? {
        if let Some(mut cursor) = stmt.fetch()? {
            if let Some(v) = cursor.get_data::<String>(1)? {
                results.push(v);
            };
        };
        stmt.close_cursor()?;
    };

    if results.len() != 1 {
         // return error no siteid found or found null value
         return Err(DBError::new("no site found or null id").into())
    }

    // validate prefix is of account of 001
    // SF doesn't keep their list updated... they point to this guys...
    // http://www.fishofprey.com/2011/09/obscure-salesforce-object-key-prefixes.html
    let account_id= results.remove(0);
    if account_id[0..3] != format!("{}", "001") {
        // return error sfAccountID is invalid
        return Err(DBError::new("returned sf account id is invalid").into())
    }

    Ok(account_id)
}

 async fn get_sf_cases(account_id: String, client: &rustforce::Client) -> Result<QueryResponse<Cases>, Box<dyn std::error::Error>>{
    let get_cases_soql = format!("select CaseNumber,
            Subject,
            Contact_Name__c,
         FORMAT(LastModifiedDate),
         FORMAT(CreatedDate),
         Owner.name,
         Status,
         Resolution__c,
         As_Stated_By_Customer__c,
         (select 
            Asset_Number__c,
             Issue_as_Stated_by_Customer__c,
             Resolution__c,
              Status, 
              WorkOrderNumber ,
              Workorder.Owner.name
              from WorkOrders)
        from Case
        where AccountId = '{}'
        and ((Status='New' and CreatedDate >= LAST_N_MONTHS:2)
    or (Status in ('In Process', 'Follow up', 'Follow up - RMA', 'Investigation', 'Pend Tech', 'Tech Visit', '3rd Tech', 'Repair', 'Outstanding Items') and CreatedDate >= LAST_N_MONTHS:6)
    or (Status not in ('New', 'In Process', 'Follow up', 'Follow up - RMA', 'Investigation', 'Pend Tech', 'Tech Visit', '3rd Tech', 'Repair', 'Outstanding Items') and CreatedDate >= LAST_N_MONTHS:2))", account_id);

    let res: QueryResponse<Cases> = client.query(&get_cases_soql).await?;

     Ok(res)
}

async fn site_cases(site: web::Path<u32>, data: web::Data<AppState>) -> impl Responder {
    match get_sf_account(&site as &u32, &data.pool) {
        Ok(account_id) => {
           match get_sf_cases(account_id, &data.client).await {
               Ok(cases) => return HttpResponse::Ok()
                        .content_type("application/json")
                        .json(&cases.records),
               Err(e) => HttpResponse::Ok()
                   .content_type("text")
                   .body(e.to_string())
            }
        }
        Err(e) => {
            let msg = e.to_string();
            let slice = &msg[..] ;
            HttpResponse::Ok()
                .status(StatusCode::INTERNAL_SERVER_ERROR)
                .reason(slice)
                .finish()
        }
    }

    //sites with nothing 1259, 1568, 1619, 1621, 1622, 1819
    // returns []
    // 519 most cases atm
}

#[actix_rt::main]
async fn main() -> std::io::Result<()> {
    use actix_web::{middleware::Logger, App, HttpServer};

    // Port configuration
    // With aspnetcore hosting bundle installed the environment variable below will be created implicitly.
    let port = match std::env::var("ASPNETCORE_PORT") {
        Ok(port) => port,
        Err(_) => {
            println!("Unable to match env var setting to default port :4000");
            "4000".to_string()
        }
    };

    //for test instance cs196
    let client_id = String::from(
        "3MVG9c1ghSpUbLl8ihvSJ53WWmhpvaRzuIglxDpyZP4rgEybvrwOel2qqmgJi9zzlCiIephsANDNXb3l8kgpm",
    );
    let client_secret =
        String::from("27372AE1209540E65EB0BAE26D81A8B2227C12278D3C643C36724150139E19D7");
    let username = String::from("arlow.farrell@enovatemedical.com");
    let password = String::from("3n0vat3");
    let mut client = Client::new(client_id, client_secret);
    // still unsure how connected apps/permission work
    // unable to login with arlow account in test but can here
    // yet I created the app in sand I have access to prod
    // even setting the instance changes nothing.
    // client.set_instance_url(&"https://CS196.salesforce.com");

    client
        .login_with_credential(username, password)
        .await
        .unwrap();

    // Set configuration variable to bind_address either dev or hosted
    let bind_address = format!("localhost:{}", port);

    // Setup App State
    let state = web::Data::new(AppState {
        pool: {
            let manager = r2d2_odbc::ODBCConnectionManager::new("DSN=Prod64Native;");
            r2d2::Pool::builder().max_size(5).build(manager).unwrap()
        },
        client,
    });

    // Log configuration
    std::env::set_var("RUST_LOG", "RhythmSalesforceAPI=error,actix_http=error");
    env_logger::init();

    // Setup server
    HttpServer::new(move || {
        App::new()
            .wrap(Logger::default())
            // you have to use app_data vs data originally registered_data otherwise the potential memory location is not in sync
            .app_data(state.clone())
            .route("/cases/{site_id}", web::get().to(site_cases))
            // .route("/sftest", web::get().to(sf_test))
    })
        .bind(&bind_address)
        .unwrap()
        .keep_alive(120)
        .run()
        .await
}
